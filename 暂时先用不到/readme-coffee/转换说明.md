# Serverless到单体应用转换说明

本文档详细说明了从AWS Serverless架构到单体应用的转换过程和关键决策。

## 转换概述

**原架构**: AWS Serverless（Lambda + DynamoDB + EventBridge + Step Functions + API Gateway + Cognito + IoT）  
**目标架构**: Node.js单体应用（Express.js + 内存存储 + EventEmitter）

## 架构对比

### 原Serverless架构组件

| 服务 | AWS组件 | 用途 |
|------|---------|------|
| 计算 | AWS Lambda | 函数即服务，按需执行 |
| 数据库 | DynamoDB | NoSQL数据库 |
| API网关 | API Gateway | RESTful API管理 |
| 事件总线 | EventBridge | 服务间事件通信 |
| 工作流编排 | Step Functions | 状态机工作流 |
| 认证 | Cognito | 用户认证和授权 |
| 实时通信 | IoT Core | 实时消息推送 |
| 存储 | S3 | 对象存储 |
| CDN | CloudFront | 内容分发 |

### 单体应用架构组件

| 服务 | 实现方式 | 说明 |
|------|----------|------|
| 计算 | Express.js路由处理器 | 同步/异步函数 |
| 数据库 | JavaScript Map | 内存键值存储 |
| API网关 | Express.js | HTTP服务器 |
| 事件总线 | EventEmitter | Node.js内置事件系统 |
| 工作流编排 | 异步JavaScript函数 | 手动状态管理 |
| 认证 | 查询参数验证 | 简化的用户识别 |
| 实时通信 | 控制台日志 | 事件日志记录 |
| 存储 | 无 | 不需要对象存储 |
| CDN | 无 | 不需要CDN |

## 详细转换映射

### 1. Lambda函数 → Express路由处理器

**原架构 (Lambda)**:
```javascript
// getQRCode Lambda函数
exports.handler = async (event) => {
  // Lambda事件处理逻辑
  const eventId = event.queryStringParameters?.eventId;
  // ...
  return {
    statusCode: 200,
    body: JSON.stringify({...})
  };
}
```

**单体应用 (Express)**:
```javascript
// Express路由处理器
async function getQRCode(req, res) {
  const eventId = req.query.eventId;
  // ...
  res.status(200).json({...});
}

app.get('/qr-code', getQRCode);
```

### 2. DynamoDB → 内存Map

**原架构 (DynamoDB)**:
```javascript
const AWS = require('aws-sdk');
const documentClient = new AWS.DynamoDB.DocumentClient();

await documentClient.put({
  TableName: 'orders',
  Item: { PK: 'orders', SK: orderId, ... }
}).promise();
```

**单体应用 (内存Map)**:
```javascript
const database = require('./services/database');

database.putItem('orders', {
  PK: 'orders',
  SK: orderId,
  ...
});
```

### 3. EventBridge → EventEmitter

**原架构 (EventBridge)**:
```javascript
const eventbridge = new AWS.EventBridge();

await eventbridge.putEvents({
  Entries: [{
    Detail: JSON.stringify({ orderId, userId }),
    DetailType: 'Validator.NewOrder',
    EventBusName: 'Serverlesspresso',
    Source: 'serverlesspresso'
  }]
}).promise();
```

**单体应用 (EventEmitter)**:
```javascript
global.eventBus.emit('Validator.NewOrder', {
  'detail-type': 'Validator.NewOrder',
  source: 'serverlesspresso',
  detail: { orderId, userId },
  time: new Date().toISOString()
});
```

### 4. Step Functions → 异步函数

**原架构 (Step Functions ASL)**:
```json
{
  "StartAt": "Check Shop Status",
  "States": {
    "Check Shop Status": {
      "Type": "Task",
      "Resource": "arn:aws:states:::dynamodb:getItem",
      "Next": "Is Shop Open?"
    },
    "Is Shop Open?": {
      "Type": "Choice",
      "Choices": [...]
    }
  }
}
```

**单体应用 (JavaScript)**:
```javascript
async function startOrderWorkflow(orderId, userId, eventId) {
  // 检查商店状态
  const shopStatus = await checkShopStatus(eventId);
  
  if (!shopStatus.isOpen) {
    emitShopUnavailable(userId, eventId);
    return;
  }
  
  // 检查容量
  const hasCapacity = await checkCapacity();
  
  if (!hasCapacity) {
    emitShopUnavailable(userId, eventId);
    return;
  }
  
  // 继续工作流...
}
```

### 5. API Gateway集成 → Express路由

**原架构 (API Gateway + DynamoDB直接集成)**:
```yaml
x-amazon-apigateway-integration:
  httpMethod: "POST"
  uri: "arn:aws:apigateway:${AWS::Region}:dynamodb:action/Query"
  requestTemplates:
    application/json: |
      {
        "TableName": "serverlesspresso-order-table",
        "KeyConditionExpression": "#ORDERSTATE = :ORDERSTATE",
        ...
      }
```

**单体应用 (Express + 函数)**:
```javascript
app.get('/orders', async (req, res) => {
  const { state, eventId } = req.query;
  const orderState = `${eventId}-${state}`;
  
  const orders = database.query('orders', {
    IndexName: 'GSI-status',
    ORDERSTATE: orderState
  });
  
  res.status(200).json(orders);
});
```

### 6. Cognito认证 → 简化认证

**原架构 (Cognito)**:
```yaml
Auth:
  DefaultAuthorizer: MyCognitoAuthorizor
  Authorizers:
    MyCognitoAuthorizor:
      UserPoolArn: !Ref UserPoolARNParameter
```

**单体应用 (查询参数)**:
```javascript
function getUserId(req) {
  // 从Authorization header提取
  const authHeader = req.headers.authorization;
  if (authHeader) {
    const match = authHeader.match(/userId=([^;]+)/);
    if (match) return match[1];
  }
  
  // 从查询参数获取
  if (req.query.userId) return req.query.userId;
  
  // 生成默认ID
  return 'user-' + Math.random().toString(36).substr(2, 9);
}
```

## 核心业务逻辑保留

尽管技术栈发生了变化，但所有核心业务逻辑都被完整保留：

### 1. QR码验证机制
- ✅ 时间桶概念（5分钟间隔）
- ✅ 令牌计数和递减
- ✅ 管理员权限检查

### 2. 订单工作流
- ✅ 工作流启动和任务令牌机制
- ✅ 客户超时（5分钟）
- ✅ 咖啡师超时（15分钟）
- ✅ 商店状态和容量检查
- ✅ 订单号自动生成

### 3. 订单状态管理
- ✅ 订单创建（CREATED）
- ✅ 订单完成（COMPLETED）
- ✅ 订单取消（CANCELLED）
- ✅ 订单超时（TIMEOUT）

### 4. 订单验证
- ✅ 饮品菜单验证
- ✅ 修饰符验证
- ✅ 用户ID验证

### 5. 事件驱动架构
- ✅ 完整的事件发布/订阅机制
- ✅ 服务间解耦
- ✅ 异步事件处理

## 文件结构

```
monolith-app/
├── app.js                      # 应用主入口
├── package.json                # 依赖配置
├── README.md                   # 完整文档
├── QUICKSTART.md              # 快速入门
├── test-workflow.js           # 自动化测试
├── 转换说明.md                 # 本文档
└── services/                   # 服务模块
    ├── database.js            # 数据库服务
    ├── validator.js           # 验证器服务
    ├── orderManager.js        # 订单管理服务
    ├── orderProcessor.js      # 订单处理服务
    ├── config.js              # 配置服务
    ├── publisher.js           # 发布服务
    └── counting.js            # 计数服务
```

## 主要改进和简化

### 1. 部署简化
- **原来**: 需要AWS账号、SAM CLI、多个CloudFormation栈
- **现在**: 只需 `npm install && npm start`

### 2. 开发体验
- **原来**: 需要部署到云端才能测试完整流程
- **现在**: 本地即可运行和调试

### 3. 成本
- **原来**: 按使用付费（Lambda调用、DynamoDB读写、EventBridge事件等）
- **现在**: 零云服务成本

### 4. 监控
- **原来**: CloudWatch日志分散在多个Lambda函数
- **现在**: 统一的控制台输出，易于追踪

## 权衡和限制

### 1. 数据持久化
- **限制**: 使用内存存储，重启后数据丢失
- **解决方案**: 可以接入MongoDB、PostgreSQL等真实数据库

### 2. 扩展性
- **限制**: 单进程运行，垂直扩展有限
- **解决方案**: 可以使用PM2集群模式或容器化部署

### 3. 高可用
- **限制**: 单点故障
- **解决方案**: 可以部署多个实例+负载均衡

### 4. 实时通知
- **限制**: 仅日志输出，无真实推送
- **解决方案**: 可以集成WebSocket或SSE

## 测试验证

### 自动化测试覆盖
✅ QR码生成和验证  
✅ 订单创建流程  
✅ 订单提交验证  
✅ 订单状态查询  
✅ 咖啡师认领订单  
✅ 订单完成流程  
✅ 订单取消流程  
✅ 配置管理  

### 运行测试
```bash
# 终端1：启动应用
npm start

# 终端2：运行测试
npm test
```

## 总结

本转换成功地将一个复杂的Serverless微服务架构转换为传统的单体应用，同时：

1. **保留了所有核心功能** - 没有功能缺失
2. **保持了代码清晰性** - 采用模块化设计
3. **简化了部署和测试** - 本地即可运行
4. **便于学习和理解** - 无需AWS知识

这个单体应用适合用于：
- 学习Serverlesspresso的业务逻辑
- 本地开发和测试
- 小规模部署
- 作为微服务架构的参考实现

